#pragma once

#include <meta>
#include <type_traits>
#include <utility>
#include <vector>
#include <string>
#include <string_view>

#include <rsl/span>
#include <rsl/string_view>
#include <rsl/expect>

#include <rsl/cli/accessor.hpp>
#include <rsl/cli/annotations.hpp>
#include <rsl/cli/spec.hpp>
#include <rsl/cli/parser.hpp>

namespace rsl {

class ProgramInfo {
  static std::string& get_name();

public:
  static void set_name(std::string_view arg0);
  static std::string_view name() { return get_name(); }
};

template <typename T>
void parse_args(T&& object, std::vector<std::string_view> args_in) {
  auto args = _cli_impl::parse<std::remove_cvref_t<T>>(args_in);

  ProgramInfo::set_name(args.program_name);
  _cli_impl::apply_args(object, args.arguments);
  _cli_impl::apply_options(object, args.options);
}

template <typename T>
void parse_args(T&& object, int argc, char** argv) {
  return parse_args(std::forward<T>(object), {argv, argv + argc});
}

template <typename T>
T load_config(std::vector<std::string_view> args_in) {
  auto args = _cli_impl::parse<T>(args_in);

  ProgramInfo::set_name(args.program_name);
  T object = _cli_impl::construct_from_args<T>(args.arguments);
  _cli_impl::apply_options(object, args.options);

  return object;
}

template <typename T>
T load_config(int argc, char** argv) {
  return load_config<T>({argv, argv + argc});
  // compile_error(display_string_of(dealias(^^_impl::ArgumentTuple<T>)));
}

namespace _cli_impl {
void print_help(_cli_impl::Spec const& spec,
                std::string_view program_name,
                std::string_view description);

template <typename T>
[[noreturn]]
void default_help() {
  constexpr static _cli_impl::Spec spec{remove_cvref(^^T), {remove_cvref(^^T)}};
  auto program_name = ProgramInfo::name();
  auto description  = std::string_view{};
  if (auto desc = annotation_of_type<annotations::Description>(^^T); desc) {
    description = desc->data;
  }
  print_help(spec, program_name, description);
  std::exit(0);
}
}  // namespace _cli_impl

struct config {
  static std::string& get_config_path();

  template <typename T>
  [[= annotations::option]] [[noreturn]]
  static void help() {
    _cli_impl::default_help<T>();
  }
};

namespace _cli_impl {
struct cli_base {
  static constexpr auto option     = annotations::option;
  static constexpr auto positional = annotations::positional;
  static constexpr auto value      = rsl::placeholders::_0;
  static constexpr auto flag       = annotations::flag;
  using shorthand                  = annotations::Shorthand;
  using description                = annotations::Description;
};
}  // namespace _cli_impl

struct cli : _cli_impl::cli_base {
  template <typename T>
  void parse_args(this T&& self, int argc, char** argv) {
    return rsl::parse_args(std::forward<T>(self), {argv, argv + argc});
  }

  template <typename T>
    requires(std::derived_from<T, config>)
  [[= option]] static void config_path(std::string new_path) {
    T::get_config_path() = std::move(new_path);
  }

  template <typename T>
  [[= option]] [[noreturn]]
  static void help() {
    _cli_impl::default_help<T>();
  }
};

template <typename T>
struct cli_extension : _cli_impl::cli_base {
  static T& get() noexcept {
    static_assert(std::derived_from<T, cli_extension<T>>,
                  "CLI extension classes must derive from cli_extension<T> where T is the class "
                  "name of the extension");
    static_assert(std::is_default_constructible_v<T>,
                  "CLI extension classes must be default constructible");
    // T must be default constructible
    static T value{};
    return value;
  }

  static inline auto const& value = get();
  static constexpr _cli_impl::Spec get_spec() { return _cli_impl::Spec{^^T, {^^cli_extension::get}}; }

  inline static const std::nullptr_t registration = (_cli_impl::Spec::extensions().push_back(get_spec()), nullptr);
  static constexpr std::integral_constant<std::nullptr_t const*, &registration>
      registration_helper{};
};

}  // namespace rsl